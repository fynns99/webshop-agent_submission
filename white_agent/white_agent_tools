"""White/Blue Agent tools for the WebShop text benchmark.

The white agent delegates all environment control to the GREEN referee.
Actions are forwarded via JSON-RPC to the green agent server, which
hosts the WebShop environment and returns deterministic transitions.
"""

from __future__ import annotations

import json
import logging
import os
import time
import urllib.error
import urllib.request
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict
from agentbeats import tool

logger = logging.getLogger(__name__)

GREEN_HOST = os.environ.get("GREEN_AGENT_HOST", "127.0.0.1")
GREEN_PORT = int(os.environ.get("GREEN_AGENT_PORT", "9031"))
GREEN_URL = os.environ.get(
    "GREEN_AGENT_URL",
    f"http://{GREEN_HOST}:{GREEN_PORT}/jsonrpc",
)

_last_clickables: List[str] = []
_last_has_search_bar: bool = False
_last_obs: Optional[str] = None


class EnvState(BaseModel):
    observation: str
    reward: float
    done: bool
    url: Optional[str] = None
    has_search_bar: bool
    clickables: List[str]
    model_config = ConfigDict(extra="forbid")


class ResetResult(BaseModel):
    ok: bool
    instruction: str
    state: EnvState
    model_config = ConfigDict(extra="forbid")


class AvailableActions(BaseModel):
    has_search_bar: bool
    clickables: List[str]
    model_config = ConfigDict(extra="forbid")


class ActionResult(BaseModel):
    ok: bool
    action: str
    state: EnvState
    model_config = ConfigDict(extra="forbid")


class BattleInfoAck(BaseModel):
    status: str
    battle_id: str
    agent_id: str
    backend_url: str
    model_config = ConfigDict(extra="forbid")


class BattleStartAck(BaseModel):
    status: str
    battle_id: str
    message: str
    model_config = ConfigDict(extra="forbid")


class MessageStreamResult(BaseModel):
    ok: bool
    result_json: Optional[str] = None
    error: Optional[str] = None
    model_config = ConfigDict(extra="forbid")


def _post_json(url: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )
    with urllib.request.urlopen(req, timeout=10) as resp:
        body = resp.read().decode("utf-8", errors="ignore")
        return json.loads(body) if body else {}


def _green_call(name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
    payload = {
        "jsonrpc": "2.0",
        "method": "agent.tool_call",
        "params": {
            "name": name,
            "arguments": arguments,
        },
        "id": int(time.time() * 1000),
    }
    try:
        response = _post_json(GREEN_URL, payload)
        if isinstance(response, dict) and "result" in response:
            return response["result"] or {}
        return response
    except urllib.error.URLError as exc:
        raise ConnectionError(f"Failed to reach green agent at {GREEN_URL}: {exc}") from exc


def _update_available_actions(source: Dict[str, Any]) -> AvailableActions:
    global _last_clickables, _last_has_search_bar
    aa = source.get("available_actions") or {}
    _last_has_search_bar = bool(aa.get("has_search_bar", False))
    _last_clickables = list(aa.get("clickables", []))
    return AvailableActions(has_search_bar=_last_has_search_bar, clickables=_last_clickables)


def _refresh_available_actions() -> AvailableActions:
    res = _green_call("get_available_actions", {})
    return _update_available_actions(res)


def _make_env_state(res: Dict[str, Any]) -> EnvState:
    obs = res.get("observation") or ""
    reward = float(res.get("reward") or 0.0)
    done = bool(res.get("done") or False)
    aa = _update_available_actions(res)
    return EnvState(
        observation=str(obs),
        reward=reward,
        done=done,
        url=res.get("url"),
        has_search_bar=aa.has_search_bar,
        clickables=aa.clickables,
    )


def _validate_search(query: str):
    if not isinstance(query, str) or not query.strip():
        raise ValueError("search query must be a non-empty string")
    if not _last_has_search_bar:
        raise ValueError("search not allowed on this page (no search bar)")


def _validate_click(target: str):
    if not isinstance(target, str) or not target.strip():
        raise ValueError("click target must be a non-empty string")
    t = target.strip().lower()
    allowed = [c.lower() for c in _last_clickables]
    if t not in allowed:
        raise ValueError(f"click target '{target}' not in current clickables")


@tool
def reset_session(instruction: str) -> ResetResult:
    """Reset env with an instruction; return obs + available actions."""
    res = _green_call("reset_env", {"instruction": instruction})
    state = _make_env_state(res)
    global _last_obs
    _last_obs = state.observation
    return ResetResult(ok=True, instruction=instruction, state=state)


@tool
def get_available_actions() -> AvailableActions:
    """Return has_search_bar and current clickables."""
    return _refresh_available_actions()


@tool
def search(query: str) -> ActionResult:
    """Run search[query] if allowed."""
    _validate_search(query)
    action = f"search[{query.strip()}]"
    res = _green_call("step_env", {"action": action})
    state = _make_env_state(res)
    global _last_obs
    _last_obs = state.observation
    return ActionResult(ok=True, action=action, state=state)


@tool
def click(target: str) -> ActionResult:
    """Run click[target] where target is in clickables."""
    _validate_click(target)
    t = target.strip()
    action = f"click[{t}]"
    res = _green_call("step_env", {"action": action})
    state = _make_env_state(res)
    global _last_obs
    _last_obs = state.observation
    return ActionResult(ok=True, action=action, state=state)


@tool
def select(option_value: str) -> ActionResult:
    """Alias for click on an option value."""
    return click(option_value)


@tool
def buy() -> ActionResult:
    """Run click[Buy Now] when present."""
    _validate_click("Buy Now")
    action = "click[Buy Now]"
    res = _green_call("step_env", {"action": action})
    state = _make_env_state(res)
    global _last_obs
    _last_obs = state.observation
    return ActionResult(ok=True, action=action, state=state)


@tool
def battle_info(
    type: str,
    battle_id: str,
    agent_name: str,
    agent_id: str,
    backend_url: str,
) -> BattleInfoAck:
    """A2A handshake: acknowledge battle_info."""
    logger.debug(
        "battle_info: type=%s battle_id=%s agent_name=%s agent_id=%s backend_url=%s",
        type,
        battle_id,
        agent_name,
        agent_id,
        backend_url,
    )
    return BattleInfoAck(
        status="ok",
        battle_id=battle_id,
        agent_id=agent_id,
        backend_url=backend_url,
    )


@tool
def battle_start(battle_id: str, instruction: Optional[str] = None) -> BattleStartAck:
    """A2A handshake: acknowledge battle_start; optionally reset."""
    logger.info("battle_start received for battle_id=%s", battle_id)
    if instruction:
        try:
            reset_session(instruction)
        except Exception as e:
            logger.warning("reset_session failed on battle_start: %s", e)
    return BattleStartAck(status="ok", battle_id=battle_id, message="white ready")


@tool
def message_stream(message: dict) -> MessageStreamResult:
    """A2A message/stream handler for embedded JSON-RPC."""
    try:
        if isinstance(message, dict) and "parts" in message:
            for part in message["parts"]:
                if part.get("kind") == "text":
                    text = part.get("text", "")
                    if text.startswith("{") and '"jsonrpc"' in text:
                        rpc_payload = json.loads(text)
                        method = rpc_payload.get("method", "")
                        params = rpc_payload.get("params", {}) or {}

                        if method == "battle_info":
                            res = battle_info(**params).model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))
                        if method == "battle_start":
                            bid = params.get("battle_id", "unknown")
                            instr = params.get("instruction")
                            res = battle_start(bid, instr).model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))
                        if method == "search":
                            res = search(**params).model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))
                        if method == "click":
                            res = click(**params).model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))
                        if method == "select":
                            res = select(**params).model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))
                        if method == "buy":
                            res = buy().model_dump()
                            return MessageStreamResult(ok=True, result_json=json.dumps(res))

                        return MessageStreamResult(ok=False, error=f"Unknown method: {method}")

        return MessageStreamResult(ok=False, error="No valid JSON-RPC found in message")
    except Exception as e:
        return MessageStreamResult(ok=False, error=f"Failed to parse/handle message: {str(e)}")


__all__ = [
    "reset_session",
    "get_available_actions",
    "search",
    "click",
    "select",
    "buy",
    "battle_info",
    "battle_start",
    "message_stream",
]
